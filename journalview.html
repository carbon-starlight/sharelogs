<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>title</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            margin: 40px auto;
            max-width: 650px;
            font-size: 18px;
            background-color: #F6F6F6;
            color: #444;
            padding: 0 10px;
            background-color: black;
            color: white;
            /* font-family: '3270'; */
            font-family: lexend, sans;
            font-size: larger;
            scrollbar-color: white black;
        }
        #drop_zone {
            border: 2px dashed #bbb;
            border-radius: 5px;
            padding: 50px;
            text-align: center;
        }
        .scanlines {
            overflow: hidden;
            position: relative;
        }
        .scanlines:before,
        .scanlines:after {
            display: block;
            pointer-events: none;
            content: "";
            position: absolute;
        }
        .scanlines:before {
            width: 100%;
            height: 2px;
            z-index: 2147483649;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0.75;
            animation: scanline 6s linear infinite;
        }
        .scanlines:after {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 2147483648;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 0, 0, 0.3) 51%
                );
                background-size: 100% 4px;
                animation: scanlines 1s steps(60) infinite;
            }
            
            /* ANIMATE UNIQUE SCANLINE */
            @keyframes scanline {
                0% {
                    transform: translate3d(0, 200000%, 0);
                }
            }
            @keyframes scanlines {
                0% {
                    background-position: 0 50%;
                }
            }
            div {
                margin: 0;
                padding: 0;
            }
            div.scanlines {
                position: absolute;
            }
            /* div .jpg {
                width: 100vw;
            height: 100vh;
            border: none;
        }
        .jpg {
            background: url("https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Philips_PM5544.svg/800px-Philips_PM5544.svg.png")
            no-repeat;
            background-size: cover;
            } */
            /* body {
                position: relative;
                background: #1b1b1b;
                } */
                
                .datetime-local {
                    background-color: #232323;
                    color: #f3f3f3;
                    border: 2px solid #ffffff;
                    border-radius: 14px; 
                    padding: 7px 18px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-weight: 500;
                    transition: background 0.2s, color 0.2s, border 0.2s;
                    box-shadow: 0 2px 8px #0002;    
                    /* font-family: "Lexend";   set font not here, but in input[ty…*/
                }
                input[type="datetime-local"]::-webkit-calendar-picker-indicator {
                    filter: invert(1);
                }
                
                /* Minimal dark styling for all datetime-local inputs */
                input[type="datetime-local"] {
                    font-family: inherit;
                    /* font-size: inherit; */
                    font-size: 16px;
                    background: black;
                    color: #e6eef8;
                    border: 1px solid white;
                    padding: 8px 10px;
                    border-radius: 6px;
                    -webkit-appearance: none;
                    appearance: none;
                }
                
                /* Keep inner text color in WebKit-based browsers */
                input[type="datetime-local"]::-webkit-datetime-edit,
                input[type="datetime-local"]::-webkit-datetime-edit-fields-wrapper,
                input[type="datetime-local"]::-webkit-datetime-edit-text {
                    color: inherit;
                }
    
                /* Simple accessible focus hint */
                input[type="datetime-local"]:focus {
                    outline: none;
                    box-shadow: 0 0 0 4px rgba(99,102,241,0.08);
                    border-color: rgba(99,102,241,0.7);
                }
                
                input::file-selector-button {
                    font-weight: bold;
                    color: white;
                    padding: 0.5em;
                    border: thin solid white;
                    border-radius: 3px;
                    background-color: #000000;
                }
                
                @font-face {
                    font-family: '3270';
                    src: url('fonts/3270-Regular.otf') format('opentype');
                    font-weight: normal;
                    font-style: normal;
                    font-display: swap;
                }
                
                progress {
                    display: block;
                    margin: 0 auto;
                }
                
                input[type="text"] {
                    background-color: #232323;
                    color: #f3f3f3;
                    border: 2px solid #ffffff;
                    border-radius: 14px; 
                    padding: 7px 18px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    font-weight: 500;
                    transition: background 0.2s, color 0.2s, border 0.2s;
                    box-shadow: 0 2px 8px #0002;
                }

                /* Try to fix autosuggestion style overwrite? 
                Futile. Chrome problem.*/
                input:-webkit-autofill,
                input:-webkit-autofill:focus,
                input:-webkit-autofill:hover,
                input:-webkit-autofill:active {
                -webkit-text-fill-color: #f3f3f3 !important;
                box-shadow: inset 0 0 0 1000px #232323 !important;
                transition: background-color 5000s ease-in-out 0s !important;
                }

                


                
                
                
                
                /* a:link, a:visited {
                    background-color: grey;
                    color: white;
                    border: 2px solid white;
                    padding: 1px 2px;
                    text-align: center;
                    text-decoration: none;
                    display: inline-block;
                    }
                    
                    a:hover, a:active {
                        background-color: green;
                        color: white;
                    } */
                    
                    
                    </style>



</head>
<body>
    <h1 style="text-align: center;">View & Share System Logs</h1>
    <!-- <h1 class="scanlines" style="text-align: center;">View & Share System Logs</h1> -->

    <p style="text-align: center;">    
    <input style="border-width: 0.15em; border-radius: 10px;"
    type="datetime-local"
    id="share-from"
    name="meeting-time"
    value="2025-07-05T20:00" />
    
    <label for="share-to" style="margin: 5px;";"><i class="fa-solid fa-arrow-right"></i></label>
    
    <input style="border-width: 0.15em; border-radius: 10px;"
    type="datetime-local"
    id="share-to"
    name="meeting-time"
    value="2025-07-05T20:05" />
    </p>

    <script>
        function setNowAsValue() {
            const shareFrom = document.getElementById('share-from');
            const shareTo = document.getElementById('share-to');
            const now = new Date();
            timeFrom = new Date(now);
            timeFrom.setMinutes(now.getMinutes() - 15)
            console.log(timeFrom)

            // Build YYYY-MM-DDThh:mm in local time
            const pad = n => String(n).padStart(2, '0');
            const yyyy = now.getFullYear();
            const mm = pad(now.getMonth() + 1);
            const dd = pad(now.getDate());
            const hh = pad(now.getHours());
            const min = pad(now.getMinutes());

            const yyyyf = timeFrom.getFullYear();
            const mmf = pad(timeFrom.getMonth() + 1);
            const ddf = pad(timeFrom.getDate());
            const hhf = pad(timeFrom.getHours());
            const minf = pad(timeFrom.getMinutes());

            shareTo.value = `${yyyy}-${mm}-${dd}T${hh}:${min}`;
            shareFrom.value = `${yyyyf}-${mmf}-${ddf}T${hhf}:${minf}`
        }

        // Set on load
        window.addEventListener('DOMContentLoaded', setNowAsValue);

        console.log(navigator)
    </script>
    
    <p style="padding: 10px; text-align: center"><label for="file-picker" class="upload-btn" style="cursor: pointer; border:#ffffff 2px solid; border-radius: 40px; padding: 10px 20px; font-weight: bold;">Select the /var/log directory to <i class="fa-solid fa-upload"></i></label>
        <input
        type="file"
        id="file-picker"
        name="fileList"
        display="none"
        webkitdirectory
        multiple
        style="display: none"
        /></p>
        
    <p style="text-align: center;">
        <progress
        id="progress"
        value="0"
        max="100"
        aria-label="File processing progress bar"
        style="display: none;"
        >
    </progress></p>

    <style>
        .checkbox-row {
            margin: 8px 0;
        }
        .checkbox-label {
            display: inline-block;
            margin-left: 6px;
            font-weight: 600;
        }
        .checkbox-clarification {
            display: block;
            margin-left: 30px; /* aligns with label text, adjust if needed */
            color: #6b7280;    /* gray color (Tailwind slate-500-ish) */
            font-size: 0.875rem; /* slightly smaller than main label */
            line-height: 1.2;
        }
    </style>

    <div class="checkbox-row" style="margin-top: 1.7em;">
    <input type="checkbox" id="remove_sensitive_checkbox" name="scales" checked />
    <label class="checkbox-label" for="remove_sensitive_checkbox">
        Attempt to remove potentially sensitive data
    </label>
    <span class="checkbox-clarification">
        Logs are designed to omit private information like passwords, but 
        some user-unique data like locale or IP adresses may be present
        <!-- If checked, an attempt to parse and hide this data will be made -->
    </span>
    </div>

    <div class="checkbox-row" style="margin-bottom: 1.7em;">
    <input type="checkbox" id="lossy_compression_checkbox" name="scales" checked />
    <label class="checkbox-label" for="lossy_compression_checkbox">
        Enable lossy compression
    </label>
    <span class="checkbox-clarification">
        Reduce file size by excluding rarely useful fields and lowering precision
        of timestamps from microseconds to seconds
    </span>
    </div>

    <label>Share logs from app<span id="ending_s">s</span>: <output id="amount_of_apps_to_share">all</output> </label>
    <input id="apps_to_share_logs_of" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" name="sources" title="t" multiple style="padding: 5px 10px"></input>

    <script>
    const inputElement = document.getElementById('apps_to_share_logs_of');

    inputElement.addEventListener('input', function() {
        var words = apps_to_share_logs_of.value.trim().split(/\s+/).filter(Boolean);
        console.log(words)
        const numWords = words.length;

        console.log(numWords); // Output: 7
        amount_of_apps_to_share.textContent = numWords > 0 ? numWords : "all";
        console.log('User entered a symbol!');
        ending_s.textContent = numWords > 1 || numWords == 0 ? 's' : '';
    });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/pako@2.0.3/dist/pako.min.js"></script>

    <script type="module"> 
        import baseX from 'https://cdn.jsdelivr.net/npm/base-x@5.0.1/+esm' 
        window.baseX = baseX

        const urlParams = new URLSearchParams(window.location.search);
        console.log(urlParams)

        if (urlParams.has('sources')) {
            const share_logs_from = urlParams.get('sources').split(',');
            console.log(share_logs_from)
            apps_to_share_logs_of.value = share_logs_from.join(' ');
            amount_of_apps_to_share.textContent = share_logs_from.length > 0 ? share_logs_from.length : "all";
        }
        var fragment = window.location.hash.substring(1);
        console.log(fragment)
        
        var BASE81F = "!$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"
        var bs81f = window.baseX(BASE81F)
        
        var imported_logs = urlParams.get('fragment');
        if (fragment) {
            fragment = bs81f.decode(fragment)
            console.log('fragment:', fragment)

            
            
            const compressedData = new Uint8Array([...fragment]);
            const decompressedData = pako.inflate(compressedData);
            
            console.log('decompressedData:', decompressedData)
            
            const decoder = new TextDecoder('utf-8');
            const string = decoder.decode(decompressedData);
            console.log('string:', string)
            
            var extracted_logs = JSON.parse(string)
            console.log('extracted_logs:', extracted_logs)
            
            const logsElement = document.getElementById('logs');
            
            extracted_logs.forEach(element => {            
                console.log(element.__REALTIME_TIMESTAMP)
                var color1 = "<font color=\"white\">"
                var color2 = "</font>"
                if (element.PRIORITY == 0 || element.PRIORITY == 1 || element.PRIORITY == 2 || element.PRIORITY == 3) { color1 = "<font color=\"red\">"; color2 = "</font>" }
                if (element.PRIORITY == 4) { color1 = "<font color=\"yellow\">"; color2 = "</font>" }
                if (element.PRIORITY == 5) { color1 = "<font color=\"white\"><strong>"; color2 = "</strong></font>" }
                if (element.PRIORITY == 7) { color1 = "<font color=\"gray\">"; color2 = "</font>" }
                var verbose = ""
                for (const key in element) { if (element.hasOwnProperty(key)) { verbose += "    " + key + "=" + element[key] + "\n" } }
                logsElement.innerHTML += '<details><summary>' + color1 + (new Date(Math.floor(parseInt(element.__REALTIME_TIMESTAMP) / 1000))).toLocaleString('en-US', {month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false}).replace(/,/g, '') + ' ' + element._HOSTNAME + ' ' + element.SYSLOG_IDENTIFIER + '[' + element._PID + ']: ' + element.MESSAGE + color2 + '</summary>' + verbose + '</details>'; 
                console.log(element.MESSAGE)
            });
        }
    </script>

    <script>
        var progressBar = document.getElementById('progress');
        function convertBytesToInt(bytes, type) {
            // receives array of 4/8 bytes (as ints) and type as unsigned le64, be64, le32, be32
            if (!bytes) {
                return 0;
            }
            if (type == "le64") {
                num = bytes[0] + bytes[1] * 256 + bytes[2] * 256 ** 2 + bytes[3] * 256 ** 3 + bytes[4] * 256 ** 4 + bytes[5] * 256 ** 5 + bytes[6] * 256 ** 6 + bytes[7] * 256 ** 7;
                return num;
                // correct way ⬆
            } else if (type == "be64") {
                num = (bytes[0] << 56) | (bytes[1] << 48) | (bytes[2] << 40) | (bytes[3] << 32) | (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7];
                return num;
            } else if (type == "le32") {
                num = bytes[0] + bytes[1] * 256 + bytes[2] * 256 ** 2 + bytes[3] * 256 ** 3;
                return num;
            } else if (type == "be32") {
                num = (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];
                return num;
            } else if (type == "le16") {
                num = bytes[0] | (bytes[1] << 8);
                return num;
            } else if (type == "be16") {
                num = (bytes[0] << 8) | bytes[1];
                return num;
            }
        }

        var extracted_logs = [];

        document.addEventListener('allLogsExtracted', () => {
            console.log('All logs extracted (event)');

            console.log("logs:", extracted_logs)
                
            const logsElement = document.getElementById('logs');

            console.warn("extracted_logs.length:", extracted_logs.length)

            if (extracted_logs.length == 0) {
                extracted_logs = [{"MESSAGE": "No relevant logs were found."}]
                console.log(extracted_logs)
            }
            
            extracted_logs.forEach(element => {
                for (const key in element) {
                    const value = element[key];
                    if (key.length + String(value).length > 4096) {
                        delete element[key];
                        console.log("Removing key-value pair:", key, value, 'because of extraordinary length: ', key.length, String(value).length);
                    }
                }
                if (remove_sensitive_checkbox.checked == true) {
                    sensitive_data_regex = {
                        "/[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/g": "░░░░░░░░-░░░░-░░░░-░░░░-░░░░░░░░░░░░",
                        "/[0-9a-fA-F]{8}[0-9a-fA-F]{4}[0-9a-fA-F]{4}[0-9a-fA-F]{4}[0-9a-fA-F]{12}/g": "░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░",
                        "/((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}/g": "░░░.░░░.░░░.░░░",
                        "/(?:[0-9A-F]{2}[-]){5}(?:[0-9A-F]{2})/g": "░░-░░-░░-░░-░░-░░",        // MAC addresses per IEEE 802
                        "/(?:[0-9A-F]{2}[-]){7}(?:[0-9A-F]{2})/g": "░░-░░-░░-░░-░░-░░-░░-░░",
                        "/(?:[0-9A-F]{2}[:]){5}(?:[0-9A-F]{2})/g": "░░:░░:░░:░░:░░:░░",         
                        // "/(?:[0-9A-F]{2}[:]){7}(?:[0-9A-F]{2})/g": "░░:░░:░░:░░:░░:░░:░░:░░",
                        // "/(?:[0-9A-F]{2}[.]){5}(?:[0-9A-F]{2})/g": "░░.░░.░░.░░.░░.░░",
                        // "/(?:[0-9A-F]{2}[.]){7}(?:[0-9A-F]{2})/g": "░░.░░.░░.░░.░░.░░.░░.░░",
                        "/([0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4}/g": "░░░░.░░░░.░░░░"
                    }
                    for (const regexPattern in sensitive_data_regex) {
                        const regex = new RegExp(regexPattern);
                        const replacement = sensitive_data_regex[regexPattern];
                        // do something with regex and replacement
                            
                        Object.keys(element).forEach(key => {
                            if (typeof element[key] === 'string') {
                                element[key] = element[key].replace(regex, replacement);
                            }
                        });
                    }
                }
                if (lossy_compression_checkbox.checked == true) {
                    console.log("lossy compression")
                    delete element.__SEQNUM
                    delete element.__SEQNUM_ID
                    delete element._BOOT_ID
                    delete element._MACHINE_ID
                    delete element._RUNTIME_SCOPE
                    delete element._UID  
                    delete element._GID  
                    delete element._SYSTEMD_SLICE  
                    delete element.SYSLOG_FACILITY  
                    // delete element.SYSLOG_IDENTIFIER  
                    delete element._CAP_EFFECTIVE  
                    delete element._SELINUX_CONTEXT  
                    delete element._SYSTEMD_INVOCATION_ID  
                    delete element.SYSLOG_TIMESTAMP  
                    delete element._SOURCE_REALTIME_TIMESTAMP
                    delete element[""]
                    element.__REALTIME_TIMESTAMP = element.__REALTIME_TIMESTAMP.toString().slice(-6)
                }
                list_of_apps_to_share_logs_from = []
                apps_to_share_logs_of.value.split(',').forEach(element => { list_of_apps_to_share_logs_from.push(element.trim()) });
                if (list_of_apps_to_share_logs_from[0] != "") {
                    console.log(list_of_apps_to_share_logs_from.length, "apps to share logs from:", list_of_apps_to_share_logs_from)                
                    if (list_of_apps_to_share_logs_from.includes(element.SYSLOG_IDENTIFIER) == false) {
                        console.log("Excluded element: ", element)
                        extracted_logs = extracted_logs.filter(log => list_of_apps_to_share_logs_from.includes(log.SYSLOG_IDENTIFIER));
                        return
                    }
                }
                console.log(element.__REALTIME_TIMESTAMP)
                color1 = "<font color=\"white\">"
                color2 = "</font>"
                if (element.PRIORITY == 0 || element.PRIORITY == 1 || element.PRIORITY == 2 || element.PRIORITY == 3) { color1 = "<font color=\"red\">"; color2 = "</font>" }
                if (element.PRIORITY == 4) { color1 = "<font color=\"yellow\">"; color2 = "</font>" }
                if (element.PRIORITY == 5) { color1 = "<font color=\"white\"><strong>"; color2 = "</strong></font>" }
                if (element.PRIORITY == 7) { color1 = "<font color=\"gray\">"; color2 = "</font>" }
                verbose = ""
                for (const key in element) { if (element.hasOwnProperty(key)) { verbose += "    " + (key == "MESSAGE" || key == "SYSLOG_IDENTIFIER" || key == "PRIORITY" ? "<font color=\"white\">" : "<font color=\"lightgreen\">") + (key == "MESSAGE" ? "<strong>" : "") + key + "=" + element[key] + (key == "MESSAGE" ? "</strong>" : "") + (key == "MESSAGE" || key == "SYSLOG_IDENTIFIER" || key == "PRIORITY" ? "</font>" : "") + "\n" } }
                logsElement.innerHTML += '<details><summary>' + color1 + (new Date(Math.floor(parseInt(element.__REALTIME_TIMESTAMP) / 1000))).toLocaleString('en-US', {month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false}).replace(/,/g, '') + ' ' + element._HOSTNAME + ' ' + element.SYSLOG_IDENTIFIER + '[' + element._PID + ']: ' + element.MESSAGE + color2 + '</summary>' + verbose + '</details>'; 
                console.log(element.MESSAGE)

            });
            // TODO: BRING THIS SHIT TO A SEPARATE FUCKING FUNCTION for a 100th time I add features to the wrong one


            // DATA COMPRESSION
            console.log('DATA COMPRESSION')

            // way 2: pako library

            

            // way 1: compression stream

            const arr = extracted_logs;

            // Convert array to JSON blob, get a byte stream, compress, and get a Blob
            const json = JSON.stringify(arr);
            const blob = new Blob([json], { type: "application/json" });

            const compressedStream = blob.stream().pipeThrough(new CompressionStream("deflate"));
            console.log('compressedStream:', compressedStream)
            const compressedBlob = new Response(compressedStream).blob().then((compressedBlob) => {
                
                
                
                
                // compressedBlob is a gzip file you can download or send
                
                console.log('array:', arr)
                console.log('is taking:', JSON.stringify(arr).length * 2, 'bytes')
                var g = JSON.stringify(arr).replace(/[\[\]\,\"]/g,''); //stringify and remove all "stringification" extra data
                console.log('length:', g.length); //this will be your length.
                console.log('that being: ' + g)
                console.log('blob:', blob)
                console.log('compressedStream:', compressedStream)
                console.log('compressedBlob:', compressedBlob)
                
                
                // TO BASE81F
                
                var BASE81F = "!$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"
                var bs81f = window.baseX(BASE81F)
                console.log(bs81f)

                console.log("12345A")

                compressedBlob.arrayBuffer().then((arrayBuffer) => {
                    const uint8Array = new Uint8Array(arrayBuffer);

                    console.log("123456")
                    
                    test = bs81f.encode([23, 25, 30, 39])
                    console.log(test)
                    fragment = bs81f.encode(uint8Array)
                    static_url = document.URL + "#" + fragment;
                    console.log("logging su: ", static_url)
                    // alert(static_url)
                    static_url_output.value = static_url;
                    static_url_output_length_output.textContent = static_url.length;
                    
                    var timeOfEnd = new Date().getTime();
                    console.log('---')
                    console.log('Execution took: ', (timeOfEnd - window.timeOfStart) / 1000, 'seconds')
                    console.log('---')
                });

                console.log(uploaded_logs_division, 'uploaded_logs_division')
                uploaded_logs_division.style.display = 'block';








            
            });
        });
        
        document.getElementById("file-picker").addEventListener("change", (event) => {
            window.timeOfStart = new Date().getTime();

            progressBar.style.display = 'block';
            
            const shareFromInput = document.getElementById('share-from');
            const shareToInput = document.getElementById('share-to');

            const shareFrom = new Date(shareFromInput.value).getTime() * 1000;
            const shareTo = new Date(shareToInput.value).getTime() * 1000;
            
            console.log(`Share from (Unix timestamp): ${shareFrom}`);
            console.log('+++')
            console.log(`Share to (Unix timestamp): ${shareTo}`);
            
            
            logging_system = "unknown"
            for (var file of event.target.files) {
                if (file.webkitRelativePath.startsWith("log/journal/")) {
                    logging_system = "journald"
                    console.log('is journald')
                    console.log(file.webkitRelativePath, 'is journald')
                }
            }
            if (logging_system == "unknown") {
                logging_system = "syslog"
                alert("Journal catalog not found, is your system using journald? Syslog is not supported yet, but will be soon.")
            }
            
            console.log('Logging system:', logging_system)
            
            let filteredFiles;
            if (logging_system == "journald") {
                console.log('IJDIJD')
                const files = Array.from(event.target.files);
                console.log(files)
                filteredFiles = files.filter(file => file.webkitRelativePath.startsWith('log/journal/'));
                console.log(filteredFiles)
            }
            console.log(filteredFiles)
            
            var numFiles = filteredFiles.length;
            console.log('Number of files:', numFiles);
            processedFiles = 0;


            for (const file of filteredFiles) {

                console.log("FILE: ", file)
                console.log(file.webkitRelativePath)
                let item = document.createElement("li");
                item.textContent = file.webkitRelativePath;

                const headEntryRealtimeBlob = file.slice(184, 192);
                console.log(headEntryRealtimeBlob);
                console.log('---');

                const tailEntryRealtimeBlob = file.slice(192, 200);
                console.log(tailEntryRealtimeBlob);
                console.log('---');

                console.log('-+-');

                const wholeFileAsBlob = file.slice(0);

                headEntryRealtimeBlob.arrayBuffer().then(buf => {
                    let bytes = new Uint8Array(buf);
                    console.log(bytes /*...*/);
                    console.log('*****')
                    var x = 1
                    var view = new DataView(buf);
                    var value = view.getBigUint64(0, true); // true for little-endian
                    console.log(value);
                    var headEntryRealtime = value;

                    tailEntryRealtimeBlob.arrayBuffer().then(buf => {
                        console.log('**+**')
                        var bytes = new Uint8Array(buf);
                        console.log(bytes /*...*/);
                        console.log(x + 1)

                        var view = new DataView(buf);
                        var value = view.getBigUint64(0, true); // true for little-endian
                        console.log(value);
                        var tailEntryRealtime = value;

                        console.log(headEntryRealtime);
                        console.log(tailEntryRealtime);
                        console.log('¡!!!!!!!¡');

                        console.log(headEntryRealtime <= shareTo && tailEntryRealtime >= shareFrom)
                        console.log(headEntryRealtime, shareTo, tailEntryRealtime, shareFrom)
                        console.log(typeof headEntryRealtime)
                        console.log(typeof shareTo)

                        if (headEntryRealtime <= shareTo && tailEntryRealtime >= shareFrom) {
                            console.log('File is relevant to the selected timeframe', file.webkitRelativePath);

                            wholeFileAsBlob.arrayBuffer().then(buf => {
                                let bytes = new Uint8Array(buf);
                                console.log(bytes)
                                console.log(typeof bytes)
                                knownEntryArrayOffsets = [];
                                console.log('aoe: ', bytes.slice(98, 106))
                                amountOfEntries = bytes[152] * 256 ** 0 + bytes[153] * 256 ** 1 + bytes[154] * 256 ** 2 + bytes[155] * 256 ** 3 + bytes[156] * 256 ** 4 + bytes[157] * 256 ** 5 + bytes[158] * 256 ** 6 + bytes[159] * 256 ** 7;
                                processedEntries = 0;

                                entryArrayOffset = bytes[176] * 256 ** 0 + bytes[177] * 256 ** 1 + bytes[178] * 256 ** 2 + bytes[179] * 256 ** 3 + bytes[180] * 256 ** 4 + bytes[181] * 256 ** 5 + bytes[182] * 256 ** 6 + bytes[183] * 256 ** 7;
                                console.log(entryArrayOffset)
                                console.log("////****\\\\\\")

                                console.log('06:', bytes[entryArrayOffset])
                                entryArraySize = bytes[entryArrayOffset + 8] + bytes[entryArrayOffset + 9] * 256 + bytes[entryArrayOffset + 10] * 256 ** 2
                                nextEntryArrayOffset = convertBytesToInt(bytes.slice(entryArrayOffset + 16, entryArrayOffset + 24), "le64")

                                while (nextEntryArrayOffset != 0) {
                                        
                                    // TODO: 32 or 64
                                    for (let i = 0; i < (entryArraySize - 8) / 8; i++) {
                                        knownEntryArrayOffsets.push(convertBytesToInt(bytes.slice(nextEntryArrayOffset + 24 + i * 4, nextEntryArrayOffset + 28 + i * 4), "le32"))
                                    }
                                    
                                    nextEntryArrayOffset = convertBytesToInt(bytes.slice(nextEntryArrayOffset + 16, nextEntryArrayOffset + 24), "le64")
                                    entryArraySize = bytes[nextEntryArrayOffset + 8] + bytes[nextEntryArrayOffset + 9] * 256 + bytes[nextEntryArrayOffset + 10] * 256 ** 2
                                    
                                    console.log('Entry Array Size:', entryArraySize)
                                    console.log('Next Entry Array Offset:', nextEntryArrayOffset)
                                    console.log('Known Entry Array Offsets:', knownEntryArrayOffsets)

                                }
                                

                                // knownEntryArrayOffsets contains offsets to entries describing structure of 03 log entries

                                // TODO: cut off first useless EntryArrays with binary search
                                // index = Math.floor(length(knownEntryArrayOffsets) / 2)
                                // while (true) {
                                //     offset = knownEntryArrayOffsets[index]
                                //     realtime = convertBytesToInt(bytes.slice(offset + 24, offset + 32), "le64")
                                //     if (realtime < shareFrom) {
                                //         // we at the left from the first one
                                //         previouslyCheckedIndex = index
                                //         index = Math.floor(index * 1.5)
                                //     } else if (realtime > shareFrom) {
                                //         // we at the right from the first one
                                //         previouslyCheckedIndex = index
                                //         index = Math.floor(index / 2)
                                //     } else {
                                //         break
                                //     }

                                // }

                                useBinarySearch = true
                                // TODO: Check for off-by-one errors

                                if (useBinarySearch) {
                                    var o = knownEntryArrayOffsets[Math.floor(knownEntryArrayOffsets.length / 2) - 2]
                                    var r = convertBytesToInt(bytes.slice(o + 24, o + 32), "le64")
                                    if (r < shareFrom) {
                                        var o = knownEntryArrayOffsets[Math.floor(knownEntryArrayOffsets.length * 0.75) - 2]
                                        var r = convertBytesToInt(bytes.slice(o + 24, o + 32), "le64")
                                        if (r < shareFrom) {
                                            // o in the last ¼
                                            knownEntryArrayOffsets = knownEntryArrayOffsets.slice(Math.floor(knownEntryArrayOffsets.length * 0.75) - 2)
                                        } else {
                                            // o in the first ¾, but not first ½
                                            knownEntryArrayOffsets = knownEntryArrayOffsets.slice(Math.floor(knownEntryArrayOffsets.length / 2) - 2)
                                        }
                                    } else if (r > shareFrom) {
                                        // o in the first ½
                                        var o = knownEntryArrayOffsets[Math.floor(knownEntryArrayOffsets.length / 4) - 2]
                                        var r = convertBytesToInt(bytes.slice(o + 24, o + 32), "le64")
                                        if (r > shareFrom) {
                                            // o in the first ¼
                                            knownEntryArrayOffsets = knownEntryArrayOffsets
                                        } else {
                                            // o in the first ½, but not first ¼
                                            knownEntryArrayOffsets = knownEntryArrayOffsets.slice(Math.floor(knownEntryArrayOffsets.length / 4) - 2)
                                        }
                                    } else {
                                        // o is offset to the exact entry, remove everything before it
                                        knownEntryArrayOffsets = knownEntryArrayOffsets.slice(knownEntryArrayOffsets.indexOf(o) - 1)
                                    }
                                }
                                // alert(String(o + " " + knownEntryArrayOffsets.length + " " + knownEntryArrayOffsets.indexOf(o)))

                                // With this 4-sector binary search: 00:02.141
                                // Without: 00:03.747 (Performance mode)
                                    

                                for (const offset of knownEntryArrayOffsets) {
                                    // Iterating through known logs (collections of 01 data objects)
                                    console.log('03:', bytes[offset])
                                    data_offsets = []
                                    data_entries = []
                                    size = bytes[offset + 8] + bytes[offset + 9] * 256 + bytes[offset + 10] * 256 ** 2
                                    seqnum = convertBytesToInt(bytes.slice(offset + 16, offset + 24), "le64")
                                    console.log('Working with realtime: ', bytes.slice(offset + 24, offset + 32))
                                    realtime = convertBytesToInt(bytes.slice(offset + 24, offset + 32), "le64")
                                    monotonic = convertBytesToInt(bytes.slice(offset + 32, offset + 40), "le64")
                                    boot_id = bytes.slice(offset + 40, offset + 56)
                                    xor_hash = convertBytesToInt(bytes.slice(offset + 56, offset + 64), "le64")

                                    console.log(bytes.slice(offset, offset + 128).toString())

                                    console.log('Size:', size)
                                    console.log('Seqnum:', seqnum)
                                    console.log('Realtime:', realtime)
                                    console.log('Monotonic:', monotonic)
                                    console.log('Boot ID:', boot_id)
                                    console.log('Xor Hash:', xor_hash)
                                    
                                    data_objects = (size - 56) / 4  // assuming 32, TODO

                                    if (!(realtime >= shareFrom && realtime <= shareTo)) {
                                        processedEntries++;
                                        console.log('Realtime is not in the selected timeframe')
                                        
                                        var progressBar = document.getElementById('progress');
                                        progressBar.value = Number(processedFiles / numFiles * 100 + processedEntries / amountOfEntries / numFiles * 100);
                                        console.log('Progress bar is: ', progressBar)
                                        console.log('Processed entries:', processedEntries);
                                        console.log('Amount of entries:', amountOfEntries);

                                        console.log('Setting progress bar to: ', Number(processedFiles / numFiles * 100 + processedEntries / amountOfEntries / numFiles * 100));

                                        // Check if, by chance, all relevant logs are already extracted

                                        if (realtime > shareTo) {
                                            console.log('All logs from given file are extracted')
                                            amountOfEntries = processedEntries
                                            break
                                            // Assuming all logs are in order, right?
                                        }

                                        continue
                                    }

                                    // Iterating through data objects

                                    for (let i = 0; i < data_objects; i++) {
                                        data_offset_offset = offset + 56 + i * 4
                                        data_offset = convertBytesToInt(bytes.slice(data_offset_offset, data_offset_offset + 4), "le32")
                                        console.log('Data offset:', data_offset)
                                        data_offsets.push(data_offset)

                                        console.log('01:', bytes[data_offset])
                                        size = bytes[data_offset + 8] + bytes[data_offset + 9] * 256 + bytes[data_offset + 10] * 256 ** 2
                                        console.log('hash is: ', bytes.slice(data_offset + 16, data_offset + 24).toString())
                                        hash = convertBytesToInt(bytes.slice(data_offset + 16, data_offset + 24), "le64")
                                        next_hash_offset = convertBytesToInt(bytes.slice(data_offset + 24, data_offset + 32), "le64")
                                        next_field_offset = convertBytesToInt(bytes.slice(data_offset + 32, data_offset + 40), "le64")
                                        entry_offset = convertBytesToInt(bytes.slice(data_offset + 40, data_offset + 48), "le64")
                                        entry_array_offset = convertBytesToInt(bytes.slice(data_offset + 48, data_offset + 56), "le64")
                                        n_entries = convertBytesToInt(bytes.slice(data_offset + 56, data_offset + 64), "le64")
                                        console.log('Size:', size)
                                        console.log('Hash:', hash)
                                        console.log('Next Hash Offset:', next_hash_offset)
                                        console.log('Next Field Offset:', next_field_offset)
                                        console.log('Entry Offset:', entry_offset)
                                        console.log('Entry Array Offset:', entry_array_offset)
                                        console.log('N Entries:', n_entries)
                                        tail_entry_array_offset = convertBytesToInt(bytes.slice(data_offset + 64, data_offset + 68), "le32")
                                        tail_entry_array_n_entries = convertBytesToInt(bytes.slice(data_offset + 68, data_offset + 72), "le32")
                                        payload = bytes.slice(data_offset + 72, data_offset + size)
                                        const decoder = new TextDecoder('utf-8');
                                        const string = decoder.decode(payload);
                                        console.log('String:', string)
                                        data_entries.push(string)
                                    }

                                    // Making the single log entry
                                    const entry = {
                                        "__SEQNUM": seqnum,
                                        "__REALTIME_TIMESTAMP": realtime,
                                        "__MONOTONIC_TIMESTAMP": monotonic,
                                        "_BOOT_ID": boot_id,
                                        
                                    };

                                    data_entries.forEach((entryStr) => {
                                    const [key, ...rest] = entryStr.split('=');
                                    const value = rest.join('=');
                                    entry[key] = value;
                                    });
                                    
                                    console.log('Entry:', entry)
                                    
                                    extracted_logs.push(entry)

                                    processedEntries++;

                                    console.log('Processed entries:', processedEntries);
                                    console.log('Amount of entries:', amountOfEntries);

                                    progressBar.value = Number(processedFiles / numFiles * 100 + processedEntries / amountOfEntries / numFiles  * 100);
                                    
                                    // const startTime = Date.now();
                                    // while (Date.now() - startTime < 15000) {
                                        // // do nothing
                                        // }
                                }
                                    
                                    
                                processedFiles++;
                                console.log(processedFiles, '_/_', numFiles);
                                progressBar.value = Number(processedFiles / numFiles * 100);

                                if (processedFiles === numFiles) {
                                    console.log('All files processed');
                                    progressBar.style.display = 'none';

                                    document.dispatchEvent(new CustomEvent('allLogsExtracted'));

                                }
                                

                                    // _packed_ struct DataObject {
                                        //         ObjectHeader object;
                                        //         le64_t hash;
                                        //         le64_t next_hash_offset;
                                        //         le64_t next_field_offset;
                                        //         le64_t entry_offset; /* the first array entry we store inline */
                                        //         le64_t entry_array_offset;
                                        //         le64_t n_entries;
                                        //         union {                                                         \
                                    //                 struct {                                                \
                                    //                         uint8_t payload[] ;                             \
                                    //                 } regular;                                              \
                                    //                 struct {                                                \
                                    //                         le32_t tail_entry_array_offset;                 \
                                    //                         le32_t tail_entry_array_n_entries;              \
                                    //                         uint8_t payload[];                              \
                                    //                 } compact;                                              \
                                    //         };                                                              \
                                    // };
                            
                        });
                        
                    } else {
                            console.log("Irrelevant file");

                            // processedFiles++;
                            // console.log(processedFiles, '_/_', numFiles);
                            // progressBar.value = Number(processedFiles / numFiles * 100);
                            
                            numFiles--;

                            if (processedFiles === numFiles) {
                                    console.log('All files processed');
                                    progressBar.style.display = 'none';
                                    allLogsWereExtracted = true;

                                    document.dispatchEvent(new CustomEvent('allLogsExtracted'));
                                    
                            }
                        };
                    });

                });                 
            }
        },
        false,
    );


    
    </script>

    <div id="quick_settings_panel">
        <!-- A single-line panel with icons allowing quick interface adjustments -->
        <!-- C                           Open external  -->
        <!-- Color -->
    </div>

    <div id="uploaded_logs_division" style="display: none;">
        <pre id="logs" class="scanlines" style="font-family: 'Source Code Pro', '3270', monospace; overflow-x:auto; overflow-y: auto; max-height: 12em;">
        </pre>

        <style>
            .link_share_clarification {
                color: gray;
                margin-top: 8px;
            }
        </style>

        <div id="static_url_output_div">
            <h3 style="margin-bottom: 5px; display: inline-block">Copy permanent link</h3><h3 id="static_url_output_length" style="margin-bottom: 5px; display: inline-block; float: right; background-color: white; color: black; border-radius: 6px; padding: 1px 15px"><output id="static_url_output_length_output">x</output> symbols</h3>
            <br>
            <div style="display: inline-block width: 100%;">
                <input id="static_url_output" type="text" style="width: calc(100% - 100px);" readonly value="" autocomplete="off">
                </input>
            <button style="width: 50px; cursor: pointer; border:#ffffff 2px solid; border-radius: 15px; padding: 8px 20px; background-color: #000000; color: #ffffff;" id="copy-button" onclick="navigator.clipboard.writeText(static_url_output.value)"><i class="fa-regular fa-clipboard"></i></button>
            </div>
            <p class="link_share_clarification">The data is encoded in the URL itself and is not dependent on any server storage</p>
        </div>
            <div id="static_url_output_div">
            <h3 style="margin-bottom: 5px; display: inline-block">Request short link</h3><h3 id="static_url_output_length" style="margin-bottom: 5px; display: inline-block; float: right; background-color: white; color: black; border-radius: 6px; padding: 1px 15px"><output id="static_short_url_output_length_output">x</output>/1,000 kB</h3>
            <br>
            <div style="display: inline-block width: 100%;">
                <input id="static_short_url_output" type="text" style="width: calc(100% - 100px); text-align: left;" placeholder="Coming soon..." readonly value="" autocomplete="off">
                </input>
            <button style="width: 50px; cursor: pointer; border:#ffffff 2px solid; border-radius: 15px; padding: 8px 20px; background-color: #000000; color: #ffffff;" id="copy-button"><i class="fa-regular fa-clipboard"></i></button>
            </div>
            <p class="link_share_clarification">The data is temporarily <span title="No permanent timeframe for storage rotation: oldest files are automatically deleted when it runs out of allocated space"><u>[?]</u></span> stored on my server. Your IP will be logged to prevent spam</p>
        </div>
    </div>
</body>
</html>